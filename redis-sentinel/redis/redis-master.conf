# =============================================================================
# Redis Master Configuration for KasagiEngine
# =============================================================================
# This configuration is optimized for real-time WebSocket state synchronization.
# The master handles all write operations and replicates to 2 replicas.
# =============================================================================

# -----------------------------------------------------------------------------
# NETWORK CONFIGURATION
# -----------------------------------------------------------------------------

# Bind to all interfaces (required for Docker networking)
# In production, consider binding to specific interfaces for security
bind 0.0.0.0

# Standard Redis port
port 6379

# Enable protected mode only if password is set
# Since we're in a Docker network, we disable it for internal communication
protected-mode no

# TCP backlog - increase for high connection scenarios
# KasagiEngine may have many WebSocket servers connecting
tcp-backlog 511

# Close connection after client is idle for N seconds (0 = disable)
# For real-time systems, we keep connections alive
timeout 0

# TCP keepalive - detect dead connections
# Send TCP ACKs every 300 seconds to keep connections alive
tcp-keepalive 300

# -----------------------------------------------------------------------------
# GENERAL SETTINGS
# -----------------------------------------------------------------------------

# Run as a daemon (no for Docker)
daemonize no

# Supervision mode for Docker
supervised no

# PID file location
pidfile /var/run/redis/redis-server.pid

# Logging level: debug, verbose, notice, warning
# Use 'notice' for production, 'verbose' for debugging
loglevel notice

# Log to stdout for Docker log collection
logfile ""

# Number of databases (0-15 by default)
# KasagiEngine typically uses db 0 for room state
databases 16

# Show Redis logo on startup
always-show-logo no

# -----------------------------------------------------------------------------
# SNAPSHOTTING (RDB PERSISTENCE)
# -----------------------------------------------------------------------------
# RDB creates point-in-time snapshots of the dataset.
# Essential for room state recovery after crashes.

# Save conditions: save <seconds> <changes>
# Save if at least 1 key changed in 900 seconds
save 900 1
# Save if at least 10 keys changed in 300 seconds
save 300 10
# Save if at least 10000 keys changed in 60 seconds (high activity)
save 60 10000

# Stop accepting writes if RDB save fails
# Important for data integrity in real-time systems
stop-writes-on-bgsave-error yes

# Compress RDB files using LZF compression
rdbcompression yes

# Enable RDB checksum for corruption detection
rdbchecksum yes

# RDB filename
dbfilename dump.rdb

# Remove RDB file if persistence is disabled (no for safety)
rdb-del-sync-files no

# Working directory for RDB/AOF files
dir /data

# -----------------------------------------------------------------------------
# REPLICATION SETTINGS
# -----------------------------------------------------------------------------
# Master-specific replication settings.
# Replicas connect to this master and sync automatically.

# Replication backlog size - buffer for partial resync
# Larger values allow replicas to catch up after short disconnections
# Important for real-time systems where data flows constantly
repl-backlog-size 64mb

# Time (seconds) before releasing backlog after all replicas disconnect
# Keep for 1 hour in case replica reconnects
repl-backlog-ttl 3600

# Master can accept writes even if no replicas are connected
# Set to 0 for availability (important for real-time systems)
min-replicas-to-write 0

# Maximum lag (seconds) for a replica to be considered healthy
min-replicas-max-lag 10

# Replica announces its IP/port to master
# Docker networking handles this automatically
replica-announce-ip redis-master
replica-announce-port 6379

# -----------------------------------------------------------------------------
# APPEND ONLY FILE (AOF) PERSISTENCE
# -----------------------------------------------------------------------------
# AOF logs every write operation for better durability.
# Combined with RDB for optimal recovery.

# Enable AOF persistence
appendonly yes

# AOF filename
appendfilename "appendonly.aof"

# AOF directory (relative to 'dir')
appenddirname "appendonlydir"

# Fsync policy:
# - always: fsync after every write (slowest, safest)
# - everysec: fsync every second (good balance) ‚Üê RECOMMENDED
# - no: let OS decide (fastest, least safe)
appendfsync everysec

# Don't fsync during BGSAVE/BGREWRITEAOF
# Improves performance during heavy writes
no-appendfsync-on-rewrite no

# Auto-rewrite AOF when it grows by 100%
auto-aof-rewrite-percentage 100

# Minimum AOF size before considering rewrite
auto-aof-rewrite-min-size 64mb

# Load truncated AOF files (important for recovery)
aof-load-truncated yes

# Enable AOF-RDB preamble for faster loading
aof-use-rdb-preamble yes

# AOF timestamp annotations for debugging
aof-timestamp-enabled no

# -----------------------------------------------------------------------------
# MEMORY MANAGEMENT
# -----------------------------------------------------------------------------
# Memory settings for real-time state management.

# Maximum memory limit (adjust based on your server)
# 0 = no limit, but set a reasonable limit in production
maxmemory 1gb

# Eviction policy when maxmemory is reached
# volatile-lru: evict keys with TTL using LRU
# allkeys-lru: evict any key using LRU
# noeviction: return error on writes (safest for real-time state)
maxmemory-policy volatile-lru

# LRU sample size for eviction decisions
maxmemory-samples 5

# -----------------------------------------------------------------------------
# LAZY FREEING
# -----------------------------------------------------------------------------
# Async deletion to avoid blocking on large key deletions.
# Critical for real-time systems to prevent latency spikes.

# Use async deletion for UNLINK instead of DEL
lazyfree-lazy-eviction yes
lazyfree-lazy-expire yes
lazyfree-lazy-server-del yes

# Async flush on replica during full resync
replica-lazy-flush yes

# Use async deletion for user commands
lazyfree-lazy-user-del yes

# Use async flush for FLUSHALL/FLUSHDB
lazyfree-lazy-user-flush yes

# -----------------------------------------------------------------------------
# THREADING
# -----------------------------------------------------------------------------
# I/O threading for improved performance on multi-core systems.

# Number of I/O threads (1 = disabled)
# Set to number of cores - 1 for best performance
io-threads 4

# Enable I/O threads for reads (disabled by default)
io-threads-do-reads yes

# -----------------------------------------------------------------------------
# CLIENT SETTINGS
# -----------------------------------------------------------------------------
# Client connection and buffer settings.

# Maximum number of connected clients
# KasagiEngine may have many WebSocket server instances
maxclients 10000

# Client output buffer limits
# pubsub: important for real-time delta broadcasting
# Soft limit: 32mb for 60 seconds
# Hard limit: 64mb immediate disconnect
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 64mb 32mb 60

# -----------------------------------------------------------------------------
# PUB/SUB SETTINGS
# -----------------------------------------------------------------------------
# Critical for KasagiEngine's real-time delta broadcasting.

# Maximum Pub/Sub channels per client (0 = unlimited)
# KasagiEngine clients may subscribe to many room channels
# pubsub-channels 0

# -----------------------------------------------------------------------------
# SLOW LOG
# -----------------------------------------------------------------------------
# Log slow queries for performance debugging.

# Log queries slower than 10ms (10000 microseconds)
slowlog-log-slower-than 10000

# Keep last 128 slow queries
slowlog-max-len 128

# -----------------------------------------------------------------------------
# ACTIVE DEFRAGMENTATION
# -----------------------------------------------------------------------------
# Reduce memory fragmentation over time.

# Enable active defragmentation
activedefrag yes

# Start defrag when fragmentation exceeds 10%
active-defrag-ignore-bytes 100mb
active-defrag-threshold-lower 10
active-defrag-threshold-upper 100

# CPU effort for defrag (1-100)
active-defrag-cycle-min 1
active-defrag-cycle-max 25

# Maximum keys to scan per cycle
active-defrag-max-scan-fields 1000

